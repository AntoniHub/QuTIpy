'''
This code is part of QuTIPy.

(c) Copyright Sumeet Khatri, 2021

This code is licensed under the Apache License, Version 2.0. You may
obtain a copy of this license in the LICENSE.txt file in the root directory
of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.

Any modifications or derivative works of this code must retain this
copyright notice, and modified files need to carry a notice indicating
that they have been altered from the originals.
'''


import numpy as np
from scipy.linalg import eig

from qutipy.general_functions import eye,ket,tensor
from qutipy.linalg import gram_schmidt



def Kraus_representation(P,dimA,dimB):

    '''
    Takes a Choi representation P of a channel and returns its Kraus representation.
    
    The Choi representation is defined with the channel acting on the second half of
    the maximally entangled vector.
    '''

    D,U=eig(P)

    U_cols=U.shape[1]

    U=np.matrix(U)

    #print(U)

    # Need to check if the matrix U generated by eig is unitary (up to numerical precision)
    check1=np.allclose(eye(dimA*dimB),U*U.H)
    check2=np.allclose(eye(dimA*dimB),U.H*U)

    if check1 and check2:
        U=np.array(U)
    
    # If U is not unitary, use Gram-Schmidt to make it unitary (i.e., make the columns of U orthonormal)
    else:
        C=gram_schmidt([U[:,i] for i in range(U_cols)],dimA*dimB)
        U=np.sum([tensor(ket(U_cols,i).H,C[i]) for i in range(U_cols)],0)
        #print(U)
    K=[]

    for i in range(U_cols):
        Col=U[:,i]
        K_tmp=np.matrix(np.sqrt(D[i])*Col.reshape([dimA,dimB]))
        K.append(K_tmp.transpose())

    return K